use std::{
    collections::{HashMap, HashSet},
    marker::PhantomData,
};
use wg_2024::{network::NodeId, packet::NodeType};

pub trait EdgeType {}

#[derive(Debug)]
pub struct Directed;
impl EdgeType for Directed {}

#[derive(Debug)]
pub struct Undirected;
impl EdgeType for Undirected {}

pub enum EdgeError {
    Edge,
    NodeId,
    SelfLoop,
}

#[derive(Debug)]
struct Node {
    ty: NodeType,
    edges: HashSet<NodeId>,
}

#[derive(Debug)]
pub struct Topology<Ty = Directed> {
    ty: PhantomData<Ty>,
    graph: HashMap<NodeId, Node>,
}

pub type DiTopology = Topology<Directed>;
pub type UnTopology = Topology<Undirected>;

impl<Ty> Topology<Ty>
where
    Ty: EdgeType,
{
    pub fn add_node(&mut self, id: NodeId, ty: NodeType) {
        self.graph.insert(
            id,
            Node {
                ty,
                edges: HashSet::new(),
            },
        );
    }
}

impl DiTopology {
    pub fn new() -> Self {
        Self {
            ty: PhantomData,
            graph: HashMap::new(),
        }
    }
    pub fn add_edge(&mut self, from: NodeId, to: NodeId) -> Result<bool, EdgeError> {
        if from == to {
            Err(EdgeError::SelfLoop)
        } else if !self.graph.contains_key(&from) || !self.graph.contains_key(&to) {
            Err(EdgeError::NodeId)
        } else if self.graph[&from].ty != NodeType::Drone && self.graph[&to].ty != NodeType::Drone {
            Err(EdgeError::Edge)
        } else {
            Ok(self.graph.get_mut(&from).unwrap().edges.insert(to))
        }
    }
}

impl UnTopology {
    pub fn new_undirected() -> Self {
        Self {
            ty: PhantomData,
            graph: HashMap::new(),
        }
    }
    pub fn add_edge(&mut self, from: NodeId, to: NodeId) -> Result<bool, EdgeError> {
        if from == to {
            Err(EdgeError::SelfLoop)
        } else if !self.graph.contains_key(&from) || !self.graph.contains_key(&to) {
            Err(EdgeError::NodeId)
        } else if self.graph[&from].ty != NodeType::Drone && self.graph[&to].ty != NodeType::Drone {
            Err(EdgeError::Edge)
        } else {
            Ok(self.graph.get_mut(&from).unwrap().edges.insert(to)
                || self.graph.get_mut(&to).unwrap().edges.insert(from))
        }
    }
}

impl TryFrom<DiTopology> for UnTopology {
    type Error = DiTopology;
    fn try_from(value: DiTopology) -> Result<Self, Self::Error> {
        for (id, node) in value.graph.iter() {
            for neighbor in node.edges.iter() {
                if !value.graph[&neighbor].edges.contains(id) {
                    return Err(value);
                }
            }
        }
        Ok(UnTopology {
            ty: PhantomData,
            graph: value.graph,
        })
    }
}
